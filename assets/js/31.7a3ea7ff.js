(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{511:function(e,v,_){"use strict";_.r(v);var a=_(4),c=Object(a.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"前端缓存-后端缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存-后端缓存"}},[e._v("#")]),e._v(" 前端缓存/后端缓存")]),e._v(" "),_("p",[e._v("基本的网络请求就是三个步骤：请求、处理、响应。")]),e._v(" "),_("p",[e._v("后端缓存主要集中于"),_("strong",[e._v("处理")]),e._v("步骤，通过保持数据库连接，存储处理结果等方式缩短处理时间，尽快进入"),_("strong",[e._v("响应")]),e._v("步骤。")]),e._v(" "),_("p",[e._v("前端缓存则可以在剩下的"),_("strong",[e._v("请求")]),e._v("和"),_("strong",[e._v("响应")]),e._v("中进行。在"),_("strong",[e._v("请求")]),e._v("步骤中，浏览器也可以通过存储结果的方式直接使用资源，省去了发送请求；而"),_("strong",[e._v("响应")]),e._v("步骤需要浏览器和服务器共同配合，通过减少响应内容来缩短传输时间。")]),e._v(" "),_("h2",{attrs:{id:"按缓存位置分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#按缓存位置分类"}},[e._v("#")]),e._v(" 按缓存位置分类")]),e._v(" "),_("p",[e._v("按照缓存位置分类以及优先级如下：(由上到下寻找，找到即返回；找不到则继续)")]),e._v(" "),_("ol",[_("li",[e._v("Service Worker")]),e._v(" "),_("li",[e._v("Memory Cache")]),e._v(" "),_("li",[e._v("Disk Cache")]),e._v(" "),_("li",[e._v("网络请求")])]),e._v(" "),_("h3",{attrs:{id:"memory-cache"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[e._v("#")]),e._v(" memory cache")]),e._v(" "),_("p",[e._v("memory cache 是内存中的缓存，(与之相对 disk cache 就是硬盘上的缓存)。按照操作系统的常理：先读内存，再读硬盘。")]),e._v(" "),_("p",[e._v("几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 注定只能是个“短期存储”。常规情况下，浏览器的 TAB 关闭后该次浏览的 memory cache 便告失效 (为了给其他 TAB 腾出位置)。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。")]),e._v(" "),_("p",[e._v("在从 memory cache 获取缓存内容时，浏览器会忽视例如 "),_("code",[e._v("max-age=0")]),e._v(", "),_("code",[e._v("no-cache")]),e._v(" 等头部配置。例如页面上存在几个相同 "),_("code",[e._v("src")]),e._v(" 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。这是因为 memory cache 只是短期使用，大部分情况生命周期只有一次浏览而已。而 "),_("code",[e._v("max-age=0")]),e._v(" 在语义上普遍被解读为“不要在下次浏览时使用”，所以和 memory cache 并不冲突。\n但如果真心不想让一个资源进入缓存，就连短期也不行，那就需要使用 "),_("code",[e._v("no-store")]),e._v("。存在这个头部配置的话，即便是 memory cache 也不会存储，自然也不会从中读取了。")]),e._v(" "),_("h3",{attrs:{id:"disk-cache"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#disk-cache"}},[e._v("#")]),e._v(" disk cache")]),e._v(" "),_("p",[e._v("disk cache 也叫 HTTP cache，顾名思义是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。而且它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。")]),e._v(" "),_("p",[e._v("disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。")]),e._v(" "),_("p",[e._v("凡是持久性存储都会面临容量增长的问题，disk cache 也不例外。在浏览器自动清理时，会有神秘的算法去把“最老的”或者“最可能过时的”资源删除，因此是一个一个删除的。不过每个浏览器识别“最老的”和“最可能过时的”资源的算法不尽相同，可能也是它们差异性的体现。")]),e._v(" "),_("h3",{attrs:{id:"service-worker"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[e._v("#")]),e._v(" Service Worker")]),e._v(" "),_("p",[e._v("上述的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断 & 进行的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。")]),e._v(" "),_("p",[e._v("Service Worker 能够操作的缓存是有别于浏览器内部的 memory cache 或者 disk cache 的。我们可以从 Chrome 的 F12 中，Application -> Cache Storage 找到这个单独的“小金库”。除了位置不同之外，这个缓存是永久性的，即关闭 TAB 或者浏览器，下次打开依然还在(而 memory cache 不是)。有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。\n如果 Service Worker 没能命中缓存，一般情况会使用 fetch() 方法继续获取资源。这时候，浏览器就去 memory cache 或者 disk cache 进行下一次找缓存的工作了。注意：经过 Service Worker 的 fetch() 方法获取的资源，即便它并没有命中 Service Worker 缓存，甚至实际走了网络请求，也会标注为 from ServiceWorker。这个情况在后面的第三个示例中有所体现。")]),e._v(" "),_("h3",{attrs:{id:"请求网络"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#请求网络"}},[e._v("#")]),e._v(" 请求网络")]),e._v(" "),_("p",[e._v("如果一个请求在上述 3 个位置都没有找到缓存，那么浏览器会正式发送网络请求去获取内容。之后容易想到，为了提升之后请求的缓存命中率，自然要把这个资源添加到缓存中去。具体来说：")]),e._v(" "),_("ol",[_("li",[e._v("根据 Service Worker 中的 handler 决定是否存入 Cache Storage (额外的缓存位置)。")]),e._v(" "),_("li",[e._v("根据 HTTP 头部的相关字段("),_("code",[e._v("Cache-control")]),e._v(", "),_("code",[e._v("Pragma")]),e._v(" 等)决定是否存入 disk cache")]),e._v(" "),_("li",[e._v("memory cache 保存一份资源 的引用，以备下次使用。")])]),e._v(" "),_("h2",{attrs:{id:"按失效策略分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#按失效策略分类"}},[e._v("#")]),e._v(" 按失效策略分类")]),e._v(" "),_("p",[e._v("memory cache 是浏览器为了加快读取缓存速度而进行的自身的优化行为，不受开发者控制，也不受 HTTP 协议头的约束，算是一个黑盒。\nService Worker 是由开发者编写的额外的脚本，且缓存位置独立，出现也较晚，使用还不算太广泛。\n所以我们平时最为熟悉的其实是 disk cache，也叫 HTTP cache (因为不像 memory cache，它遵守 HTTP 协议头中的字段)。平时所说的强制缓存，对比缓存，以及 Cache-Control 等，也都归于此类。")]),e._v(" "),_("h3",{attrs:{id:"强制缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[e._v("#")]),e._v(" 强制缓存")]),e._v(" "),_("p",[e._v("强制缓存的含义是，当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库。")]),e._v(" "),_("p",[_("strong",[e._v("强制缓存直接减少请求数，是提升最大的缓存策略")]),e._v("。它的优化覆盖了请求数据的全部三个步骤。如果考虑使用缓存来优化网页性能的话，强制缓存应该是首先被考虑的。")]),e._v(" "),_("p",[e._v("可以造成强制缓存的字段是 "),_("code",[e._v("Cache-control")]),e._v(" 和 "),_("code",[e._v("Expires")]),e._v("。")]),e._v(" "),_("h4",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[e._v("#")]),e._v(" Expires")]),e._v(" "),_("p",[e._v("这是HTTP 1.0的字段，表示缓存到期时间，是一个绝对时间（当期时间+缓存时间），如：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("Expires: Thu, 10 Nov 2017 08:45:11 GMT\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br")])]),_("p",[e._v("在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。")]),e._v(" "),_("p",[e._v("但是，这个字段设置时有两个缺点：")]),e._v(" "),_("ol",[_("li",[e._v("由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑自信修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。")]),e._v(" "),_("li",[e._v("写法太复杂了。表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效。")])]),e._v(" "),_("h4",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[e._v("#")]),e._v(" Cache-control")]),e._v(" "),_("p",[e._v("已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。")]),e._v(" "),_("p",[e._v("这两者的区别就是前者是绝对时间，而后者是相对时间。如下：")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("Cache-control: max-age=2592000\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br")])]),_("p",[e._v("下面列举一些 "),_("code",[e._v("Cache-control")]),e._v(" 字段常用的值：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("max-age")]),e._v(": 最大有效时间")]),e._v(" "),_("li",[_("code",[e._v("must-revalidate")]),e._v("：如果超过了 "),_("code",[e._v("max-age")]),e._v(" 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。")]),e._v(" "),_("li",[_("code",[e._v("no-cache")]),e._v(": 虽然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。")]),e._v(" "),_("li",[_("code",[e._v("no-store")]),e._v(": 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制缓存和协商缓存")]),e._v(" "),_("li",[_("code",[e._v("public")]),e._v(": 所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)")]),e._v(" "),_("li",[_("code",[e._v("private")]),e._v(": 所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。")])]),e._v(" "),_("p",[e._v("这些值可以混合使用，例如 "),_("code",[e._v("Cache-control:public, max-age=2592000")]),e._v("。在混合使用时，它们的优先级如下图：\n"),_("img",{attrs:{src:"https://t1.picb.cc/uploads/2019/11/04/gYk3Y6.png",alt:"gYk3Y6.png"}})]),e._v(" "),_("p",[e._v("这里有一个疑问："),_("code",[e._v("max-age=0")]),e._v(" 和 "),_("code",[e._v("no-cache")]),e._v(" 等价吗？从规范的字面意思来说，"),_("code",[e._v("max-age")]),e._v(" 到期是 应该(SHOULD) 重新验证，而 "),_("code",[e._v("no-cache")]),e._v(" 是 必须(MUST) 重新验证。但实际情况以浏览器实现为准，大部分情况他们俩的行为还是一致的。（如果是 "),_("code",[e._v("max-age=0, must-revalidate")]),e._v(" 就和 "),_("code",[e._v("no-cache")]),e._v(" 等价了）")]),e._v(" "),_("p",[e._v("总结一下，自从 HTTP/1.1 开始，"),_("code",[e._v("Expires")]),e._v(" 逐渐被 "),_("code",[e._v("Cache-control")]),e._v(" 取代。"),_("code",[e._v("Cache-control")]),e._v(" 是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且 "),_("code",[e._v("Cache-control")]),e._v(" 的可配置性比较强大。\n"),_("strong",[_("code",[e._v("Cache-control")]),e._v(" 的优先级高于 "),_("code",[e._v("Expires")])]),e._v("，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段我们都会设置。")]),e._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),_("p",[e._v("当强制缓存失效(超过规定时间)时，就需要使用对比缓存，由服务器决定缓存内容是否失效。")]),e._v(" "),_("p",[e._v("流程上说，浏览器先请求缓存数据库，返回一个缓存标识。之后浏览器拿这个标识和服务器通讯。如果缓存未失效，则返回 HTTP 状态码 "),_("code",[e._v("304")]),e._v(" 表示继续使用，于是客户端继续使用缓存；如果失效，则返回新的数据和缓存规则，浏览器响应数据后，再把规则写入到缓存数据库。")]),e._v(" "),_("p",[_("strong",[e._v("对比缓存在请求数上和没有缓存是一致的")]),e._v("，但如果是 "),_("code",[e._v("304")]),e._v(" 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 "),_("strong",[e._v("在响应体体积上的节省是它的优点")]),e._v("。它的优化覆盖了文章开头提到过的请求数据的三个步骤中的最后一个：“响应”。通过减少响应体体积，来缩短网络传输时间。所以和强制缓存相比提升幅度较小，但总比没有缓存好。")]),e._v(" "),_("p",[e._v("对比缓存是可以和强制缓存一起使用的，作为在强制缓存失效后的一种后备方案。实际项目中他们也的确经常一同出现。")]),e._v(" "),_("p",[e._v("对比缓存有 2 组字段(不是两个)：")]),e._v(" "),_("h4",{attrs:{id:"last-modified-if-modified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[e._v("#")]),e._v(" Last-Modified & If-Modified-Since")]),e._v(" "),_("ol",[_("li",[e._v("服务器通过"),_("code",[e._v("Last-Modified")]),e._v("字段告诉客户端资源最后一次被修改的时间，如：")])]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br")])]),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[e._v("浏览器将这个值和内容一起记录在缓存数据库中")])]),e._v(" "),_("li",[_("p",[e._v("下一次请求相同资源时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 "),_("code",[e._v("Last-Modified")]),e._v(" 的值写入到请求头的 "),_("code",[e._v("If-Modified-Since")]),e._v(" 字段")])]),e._v(" "),_("li",[_("p",[e._v("服务器会将 "),_("code",[e._v("If-Modified-Since")]),e._v(" 的值与 "),_("code",[e._v("Last-Modified")]),e._v(" 字段进行对比。如果相等，则表示未修改，响应 "),_("code",[e._v("304")]),e._v(" ；反之，则表示修改了，响应 "),_("code",[e._v("200")]),e._v(" 状态码，并返回数据。")])])]),e._v(" "),_("p",[e._v("但是他还是有一定缺陷的：")]),e._v(" "),_("ul",[_("li",[e._v("如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。")]),e._v(" "),_("li",[e._v("如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。")])]),e._v(" "),_("h4",{attrs:{id:"etag-if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[e._v("#")]),e._v(" Etag & If-None-Match")]),e._v(" "),_("p",[e._v("为了解决上述问题，出现了一组新的字段 "),_("code",[e._v("Etag")]),e._v(" 和 "),_("code",[e._v("If-None-Match")])]),e._v(" "),_("p",[_("code",[e._v("Etag")]),e._v(" 存储的是文件的特殊标识(一般都是 "),_("code",[e._v("hash")]),e._v(" 生成的)，服务器存储着文件的 "),_("code",[e._v("Etag")]),e._v(" 字段。之后的流程和 "),_("code",[e._v("Last-Modified")]),e._v(" 一致，只是 "),_("code",[e._v("Last-Modified")]),e._v(" 字段和它所表示的更新时间改变成了 "),_("code",[e._v("Etag")]),e._v(" 字段和它所表示的文件 "),_("code",[e._v("hash")]),e._v("，把 "),_("code",[e._v("If-Modified-Since")]),e._v(" 变成了 "),_("code",[e._v("If-None-Match")]),e._v("。服务器同样进行比较，命中返回 "),_("code",[e._v("304")]),e._v(", 不命中返回新资源和 "),_("code",[e._v("200")]),e._v("。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("Etag")]),e._v(" 的优先级高于 "),_("code",[e._v("Last-Modified")])])]),e._v(" "),_("h2",{attrs:{id:"缓存小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存小结"}},[e._v("#")]),e._v(" 缓存小结")]),e._v(" "),_("p",[e._v("当浏览器要请求资源时")]),e._v(" "),_("ol",[_("li",[e._v("调用 Service Worker 的 fetch 事件响应（如果注册了 Service Worker）")]),e._v(" "),_("li",[e._v("查看 memory cache")]),e._v(" "),_("li",[e._v("查看 disk cache。这里又细分：\n"),_("ul",[_("li",[e._v("如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200")]),e._v(" "),_("li",[e._v("如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200")])])]),e._v(" "),_("li",[e._v("发送网络请求，等待网络响应")]),e._v(" "),_("li",[e._v("把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)")]),e._v(" "),_("li",[e._v("把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)")]),e._v(" "),_("li",[e._v("把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())")])]),e._v(" "),_("h2",{attrs:{id:"浏览器行为"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器行为"}},[e._v("#")]),e._v(" 浏览器行为")]),e._v(" "),_("p",[e._v("所谓浏览器的行为，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：")]),e._v(" "),_("ul",[_("li",[e._v("打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。")]),e._v(" "),_("li",[e._v("普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。")]),e._v(" "),_("li",[e._v("强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)。服务器直接返回 200 和最新内容。")])]),e._v(" "),_("blockquote",[_("p",[e._v("摘自 https://juejin.im/post/5c22ee806fb9a049fb43b2c5")])])])}),[],!1,null,null,null);v.default=c.exports}}]);