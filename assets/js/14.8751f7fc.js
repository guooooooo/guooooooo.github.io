(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{494:function(e,_,v){"use strict";v.r(_);var t=v(4),s=Object(t.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"commonjs的模块规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#commonjs的模块规范"}},[e._v("#")]),e._v(" CommonJS的模块规范")]),e._v(" "),v("p",[e._v("CommonJS对模块的定义主要分为"),v("strong",[e._v("模块引用")]),e._v("、"),v("strong",[e._v("模块定义")]),e._v("和"),v("strong",[e._v("模块标识")]),e._v("3个部分。")]),e._v(" "),v("h3",{attrs:{id:"模块引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块引用"}},[e._v("#")]),e._v(" 模块引用")]),e._v(" "),v("p",[e._v("在CommonJS规范中，存在"),v("code",[e._v("require()")]),e._v("方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。")]),e._v(" "),v("h3",{attrs:{id:"模块定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块定义"}},[e._v("#")]),e._v(" 模块定义")]),e._v(" "),v("p",[e._v("在模块中，上下文提供"),v("code",[e._v("require()")]),e._v("方法来引入外部模块。同时提供"),v("code",[e._v("exports")]),e._v("对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个"),v("code",[e._v("module")]),e._v("对象，它代表模块自身，而"),v("code",[e._v("exports")]),e._v("是"),v("code",[e._v("module")]),e._v("的属性。在Node中，一个文件就是一个模块，将方法挂载在"),v("code",[e._v("exports")]),e._v("对象上作为属性即可定义导出的方式。")]),e._v(" "),v("h3",{attrs:{id:"模块标识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块标识"}},[e._v("#")]),e._v(" 模块标识")]),e._v(" "),v("p",[e._v("模块标识其实就是传递给"),v("code",[e._v("require()")]),e._v("方法的参数，必须是符合小驼峰命名的字符串，或者以"),v("code",[e._v(".")]),e._v("、"),v("code",[e._v("..")]),e._v("开头的相对路径，或者绝对路径。\n模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。")]),e._v(" "),v("h2",{attrs:{id:"node-的模块实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-的模块实现"}},[e._v("#")]),e._v(" Node 的模块实现")]),e._v(" "),v("p",[e._v("Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性。")]),e._v(" "),v("p",[e._v("在Node中引入模块，需要经历以下3个步骤：\n（1）路径分析\n（2）文件定位\n（3）编译执行")]),e._v(" "),v("p",[e._v("在Node中，模块分为两类：")]),e._v(" "),v("ul",[v("li",[e._v("一类是Node提供的模块，成为核心模块；核心模块部分在Node源代码的编译过程中，编译进了二进制的执行文件。在Node进程启动时，部分核心模块就被直接加载进内容中，所以在引入时，文件定位和编译执行步骤可以省略，并且在路径分析中优先判断，所以加载速度是最快的。")]),e._v(" "),v("li",[e._v("另一类是用户编写的模块，成为文件模块。文件模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程。")])]),e._v(" "),v("h3",{attrs:{id:"优先从缓存加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优先从缓存加载"}},[e._v("#")]),e._v(" 优先从缓存加载")]),e._v(" "),v("p",[e._v("与前端浏览器会缓存静态脚本以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。\n无论是核心模块还是文件模块，"),v("code",[e._v("require()")]),e._v("方法对相同模块的二次加载都一律采用缓存优先的方式，这是"),v("strong",[e._v("第一优先级")]),e._v("的。不同之处在于核心模块的缓存检查"),v("strong",[e._v("先于")]),e._v("文件模块的缓存检查。")]),e._v(" "),v("h3",{attrs:{id:"路径分析和文件定位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#路径分析和文件定位"}},[e._v("#")]),e._v(" 路径分析和文件定位")]),e._v(" "),v("p",[e._v("对于不同形式的模块标识符，模块的查找和定位有不同程度的差异。")]),e._v(" "),v("h4",{attrs:{id:"模块标识符分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块标识符分析"}},[e._v("#")]),e._v(" 模块标识符分析")]),e._v(" "),v("p",[e._v("模块标识符在Node中主要分为以下几类：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("核心模块，如"),v("code",[e._v("path")]),e._v("、"),v("code",[e._v("fs")]),e._v("、"),v("code",[e._v("http")]),e._v("等。核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载速度最快。")])]),e._v(" "),v("li",[v("p",[e._v("路径形式的文件模块，包括以"),v("code",[e._v(".")]),e._v("、"),v("code",[e._v("..")]),e._v("开头的相对路径文件模块或者以"),v("code",[e._v("/")]),e._v("开始的绝对路径文件模块。在分析路径模块时，"),v("code",[e._v("require()")]),e._v("方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，以使二次加载时更快。")])]),e._v(" "),v("li",[v("p",[e._v("自定义模块，指的是非核心模块，也不是路径形式的标识符。可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。\n"),v("strong",[e._v("模块路径")]),e._v("是Node在定义文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。生成规则如下：")]),e._v(" "),v("ul",[v("li",[e._v("当前文件目录下的"),v("code",[e._v("node_modules")]),e._v("目录")]),e._v(" "),v("li",[e._v("父目录下的"),v("code",[e._v("node_modules")]),e._v("目录")]),e._v(" "),v("li",[e._v("父目录的父目录下的"),v("code",[e._v("node_modules")]),e._v("目录")]),e._v(" "),v("li",[e._v("沿路径向上逐级递归，直到根目录下的"),v("code",[e._v("node_modules")]),e._v("目录\nnode会在加载过程中逐个尝试模块路径中的路径，直到找到目标文件为止。")])])])]),e._v(" "),v("h4",{attrs:{id:"文件定位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件定位"}},[e._v("#")]),e._v(" 文件定位")]),e._v(" "),v("p",[e._v("文件的定位过程中，主要包括文件扩展名的分析、目录和包的处理。")]),e._v(" "),v("ul",[v("li",[e._v("文件扩展名分析\n"),v("code",[e._v("require()")]),e._v("在分析标识符的过程中，当标识符不包含文件扩展名时，Node会按"),v("code",[e._v(".js")]),e._v("、"),v("code",[e._v(".json")]),e._v("、"),v("code",[e._v(".node")]),e._v("的次序补足扩展名，依次尝试。尝试的过程中需要调用fs模块"),v("strong",[e._v("同步阻塞")]),e._v("的判断文件是否存在。为了优化加载速度，引用"),v("code",[e._v(".json")]),e._v("和"),v("code",[e._v(".node")]),e._v("文件时在传递给"),v("code",[e._v("require()")]),e._v("的标识符中带上扩展名。")]),e._v(" "),v("li",[e._v("目录分析和包\n"),v("code",[e._v("require()")]),e._v("在分析文件扩展名之后，可能没有查找到对应文件，但得到一个目录，此时Node会将目录当做一个包来处理。\n"),v("ul",[v("li",[e._v("首先会在当前目录下查找"),v("code",[e._v("package.json")]),e._v("，通过"),v("code",[e._v("JSON.parse()")]),e._v("解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。")]),e._v(" "),v("li",[e._v("如果main属性的指定的文件名错误，或者没有"),v("code",[e._v("package.json")]),e._v("文件，Node会将index当做默认文件名，然后依次查找"),v("code",[e._v("index.js")]),e._v("、"),v("code",[e._v("index.json")]),e._v("、"),v("code",[e._v("index.node")]),e._v("。")]),e._v(" "),v("li",[e._v("如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找，如果模块路径数组都被遍历完毕依然没有查找到目标文件，则会跑出查找失败的异常。")])])])]),e._v(" "),v("h3",{attrs:{id:"模块编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块编译"}},[e._v("#")]),e._v(" 模块编译")]),e._v(" "),v("p",[e._v("编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个"),v("code",[e._v("Module")]),e._v("模块对象，然后根据路径载入并编译。对于不同的文件扩展名，载入方法也有所不同。")]),e._v(" "),v("ul",[v("li",[e._v(".js文件。通过fs模块同步读取文件后编译执行")]),e._v(" "),v("li",[e._v(".json文件。通过fs模块同步读取文件后，用"),v("code",[e._v("JSON.parse()")]),e._v("解析返回结果。")]),e._v(" "),v("li",[e._v(".node文件。这是用C/C++编写的扩展文件，通过"),v("code",[e._v("dlopen()")]),e._v("方法加载最后编译生成的文件。")])]),e._v(" "),v("p",[e._v("每一个编译成功的模块都会将其文件路径作为索引缓存再"),v("code",[e._v("Module._cache")]),e._v("对象上，以提高二次引入的性能。")]),e._v(" "),v("h4",{attrs:{id:"javascript模块的编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript模块的编译"}},[e._v("#")]),e._v(" JavaScript模块的编译")]),e._v(" "),v("p",[e._v("每个模块文件中都存在着"),v("code",[e._v("require")]),e._v("、"),v("code",[e._v("exports")]),e._v("、"),v("code",[e._v("module")]),e._v("、"),v("code",[e._v("__filename")]),e._v("、"),v("code",[e._v("__dirname")]),e._v("这些变量。是因为在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了"),v("code",[e._v("(function(exports, require, module, __filename, __dirname) {\\n")]),e._v("，在尾部添加了"),v("code",[e._v("\\n});")]),e._v("。一个正常的JavaScript文件会被包装成如下样子：")]),e._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("exports"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" require"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" module"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" ___filename"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" __dirname")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 文件内容")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" math "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("require")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("'math"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  exports"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("area")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("radius")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" Math"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token constant"}},[e._v("PI")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" radius "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" radius"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br"),v("span",{staticClass:"line-number"},[e._v("7")]),v("br")])]),v("p",[e._v("这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的"),v("code",[e._v("runInThisContext()")]),e._v("方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的function对象。最后，将当前模块对象的"),v("code",[e._v("exports")]),e._v("属性、"),v("code",[e._v("require()方法")]),e._v("、"),v("code",[e._v("module")]),e._v("（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function执行。在执行之后，模块的"),v("code",[e._v("exports")]),e._v("属性被返回给了调用方。"),v("code",[e._v("exports")]),e._v("属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。")]),e._v(" "),v("h4",{attrs:{id:"json文件的编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#json文件的编译"}},[e._v("#")]),e._v(" JSON文件的编译")]),e._v(" "),v("p",[e._v("Node利用fs模块同步读取JSON文件的内容之后，调用"),v("code",[e._v("JSON.parse()")]),e._v("方法得到对象，然后将它赋给模块对象的"),v("code",[e._v("exports")]),e._v("，以供外部调用。")]),e._v(" "),v("h4",{attrs:{id:"c-c-模块的编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#c-c-模块的编译"}},[e._v("#")]),e._v(" C/C++模块的编译")]),e._v(" "),v("p",[e._v("Node调用"),v("code",[e._v("process.dlopen()")]),e._v("方法进行加载和执行。"),v("code",[e._v(".node")]),e._v("模块文件并不需要编译，只有加载和执行的过程。在执行的过程中，模块的"),v("code",[e._v("exports")]),e._v("对象与"),v("code",[e._v(".node")]),e._v("模块产生联系，然后返回给调用者。")]),e._v(" "),v("hr"),e._v(" "),v("blockquote",[v("p",[e._v("整理自《深入浅出Node.js》  第二章 模块机制")])])])}),[],!1,null,null,null);_.default=s.exports}}]);